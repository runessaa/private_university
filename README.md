# private_university

# 1.а. Дополните схему дерева файлов и модулей пакета calculator, указав, какие модули и функции в них содержатся.

basic | advanced: addition, subtraction | exponentiation, root

# 1.б. Объясните, какую роль играют файлы __init__.py в каждом каталоге пакета. Почему без них пакет не будет работать правильно?

init.py позволяет сделать импорт всего содержимого из пакета, что уменьшает затраты разработчика (упрощает работу при импорте всего пакета). Без init.py это не пакеты, а простые папки.

# 2.a. Обратите внимание на использование переменной __all__ в файле calculator/__init__.py. Объясните, как она влияет на импорт пакета.

1. Переменная __all__ контролирует экспорт имен при использовании импорта через *.
2. Она позволяет явно указать, что именно будет доступно пользователям пакета.
3. Экспортируются модули basic и advanced, но их внутренние реализации, например, addition и subtraction остаются скрытыми.

# 2.б. Удалите или закомментируйте строку __all__ = ["basic", "advanced"] в файле calculator/__init__.py. Попробуйте импортировать пакет снова. Что произошло? Объясните причину возникшей проблемы.

Нет возможности прямого вызова функции. Исключительно через указания пакета <package>.<method>.

# 2.в. Верните строку __all__ обратно. Попробуйте выполнить команду. Какие модули будут импортированы? Как можно управлять импортируемыми модулями с помощью __all__?
from calculator import *

Импортированы: basic и advanced. Управление можно реализовать редактирование самого  __all__ = ["basic", "advanced"] в файле __init__.py в качестве листа

# 3.а. В файле calculator/basic/__init__.py замените относительные импорты на абсолютные. Проверьте работоспособность пакета. Объясните разницу между относительным и абсолютным импортом. Какие преимущества и недостатки каждого из них?
from calculator.basic.addition import add
from calculator.basic.subtraction import subtract  

1. Абсолютный импорт: указывается полный путь до модуля/пакета. Преимущество - указан полный путь; недостаток - если будет изменена структура, придется лезть в файл и копаться с этими импортами. 
2. Относительный импорт: указывается путь адаптируясь под текущее положение модуля. Преимущество - нет привязаности к определенной структуре проекта; недостаток - использование исключительно в пакетах.

# 3.б. Предположим, что структура пакета изменилась, и папка basic была переименована в simple. Объясните, как это повлияет на абсолютные и относительные импорты. Какой импорт легче поддерживать при реорганизации структуры пакета?

Если абсолютный импорт, то нужно менять импорт в самом __init__.py. Проще использовать относительный импорт и не морочить себе голову, так как он банально гибче.

# 5.б. Запустите файл exponentiation.py напрямую. Что произошло? Какой вывод вы получили?

Файл запущен в самом себе -> if __name__ == "__main__" отработает и выполнит содержимое (Вывод: 32).

# 5.в. Импортируйте функцию power в main.py и запустите main.py. Выполняется ли код внутри блока if __name__ == "__main__": в файле exponentiation.py при импорте? Объясните, почему.

Файл запущен извне -> if __name__ == "__main__" не отработает и не выполнит содержимое условия.

# 6.а. Выведите переменную sys.path в main.py. Объясните, какие пути в ней содержатся и как Python использует их для поиска модулей.

sys.path хранит в себе абсолютный путь до проекта и его содержимого (пакеты, модули и т.д), путь до интерпретатора и его зависимостей. Поиск происходит при помощи __init__.py .

# 6.б. Попробуйте переместить папку calculator в другую директорию, которая не входит в sys.path. Можете ли вы теперь импортировать пакет? Что нужно сделать, чтобы Python мог найти ваш пакет?

Можно применить импорт с помощью sys.path.append(path), иначе он будет вне области видимости.

# 8.б. Объясните, какой способ импорта сработал, а какой нет, и почему.

sys.path.append(path). Относительный не отработал, так как модуль вне области видимости проекта.